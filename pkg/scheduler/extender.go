package scheduler

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/tsundata/flowline/pkg/api/meta"
	"github.com/tsundata/flowline/pkg/scheduler/framework"
	"github.com/tsundata/flowline/pkg/scheduler/framework/config"
	"net/http"
	"strings"
	"time"
)

// FailedWorkersMap represents the filtered out workers, with worker names and failure messages
type FailedWorkersMap map[string]string

// ExtenderFilterResult represents the results of a filter call to an extender
type ExtenderFilterResult struct {
	// Filtered set of workers where the stage can be scheduled; to be populated
	// only if Extender.WorkerCacheCapable == false
	Workers *meta.WorkerList
	// Filtered set of workers where the stage can be scheduled; to be populated
	// only if Extender.WorkerCacheCapable == true
	WorkerNames *[]string
	// Filtered out workers where the stage can't be scheduled and the failure messages
	FailedWorkers FailedWorkersMap
	// Filtered out workers where the stage can't be scheduled and preemption would
	// not change anything. The value is the failure message same as FailedWorkers.
	// Workers specified here takes precedence over FailedWorkers.
	FailedAndUnresolvableWorkers FailedWorkersMap
	// Error message indicating failure
	Error string
}

// ExtenderBindingResult represents the result of binding of a stage to a worker from an extender.
type ExtenderBindingResult struct {
	// Error message indicating failure
	Error string
}

// ExtenderArgs represents the arguments needed by the extender to filter/prioritize
// workers for a stage.
type ExtenderArgs struct {
	// Stage being scheduled
	Stage *meta.Stage
	// List of candidate workers where the stage can be scheduled; to be populated
	// only if Extender.WorkerCacheCapable == false
	Workers *meta.WorkerList
	// List of candidate worker names where the stage can be scheduled; to be
	// populated only if Extender.WorkerCacheCapable == true
	WorkerNames *[]string
}

// ExtenderPreemptionResult represents the result returned by preemption phase of extender.
type ExtenderPreemptionResult struct {
	WorkerNameToMetaVictims map[string]interface{}
}

// ExtenderPreemptionArgs represents the arguments needed by the extender to preempt stages on workers.
type ExtenderPreemptionArgs struct {
	// Stage being scheduled
	Stage *meta.Stage
	// Victims map generated by scheduler preemption phase
	// Only set WorkerNameToMetaVictims if Extender.WorkerCacheCapable == true. Otherwise, only set WorkerNameToVictims.
	WorkerNameToVictims     map[string]*Victims
	WorkerNameToMetaVictims map[string]interface{}
}

// Victims represents:
//   stages:  a group of stages expected to be preempted.
//   numPDBViolations: the count of violations of StageDisruptionBudget
type Victims struct {
	Stages           []*meta.Stage
	NumPDBViolations int64
}

func NewHTTPExtender(config *config.Extender) (framework.Extender, error) {
	if config.HTTPTimeout.Nanoseconds() == 0 {
		config.HTTPTimeout = time.Duration(5 * time.Second)
	}

	client := &http.Client{
		Timeout: config.HTTPTimeout,
	}
	managedResources := make(map[string]struct{})
	for _, r := range config.ManagedResources {
		managedResources[r] = struct{}{}
	}
	return &HTTPExtender{
		extenderURL:        config.URLPrefix,
		preemptVerb:        config.PreemptVerb,
		filterVerb:         config.FilterVerb,
		prioritizeVerb:     config.PrioritizeVerb,
		bindVerb:           config.BindVerb,
		weight:             config.Weight,
		client:             client,
		workerCacheCapable: config.WorkerCacheCapable,
		managedResources:   managedResources,
		ignorable:          config.Ignorable,
	}, nil
}

// HTTPExtender implements the Extender interface.
type HTTPExtender struct {
	extenderURL        string
	preemptVerb        string
	filterVerb         string
	prioritizeVerb     string
	bindVerb           string
	weight             int64
	client             *http.Client
	workerCacheCapable bool
	managedResources   map[string]struct{}
	ignorable          bool
}

func (h *HTTPExtender) Name() string {
	return h.extenderURL
}

func (h *HTTPExtender) Filter(stage *meta.Stage, workers []*meta.Worker) (filteredWorkers []*meta.Worker, failedWorkersMap map[string]string, failedAndUnresolvable map[string]string, err error) {
	var (
		result       ExtenderFilterResult
		workerList   *meta.WorkerList
		workerNames  *[]string
		workerResult []*meta.Worker
		args         *ExtenderArgs
	)
	fromWorkerName := make(map[string]*meta.Worker)
	for _, n := range workers {
		fromWorkerName[n.UID] = n
	}

	if h.filterVerb == "" {
		return workers, nil, nil, nil
	}

	if h.workerCacheCapable {
		workerNameSlice := make([]string, 0, len(workers))
		for _, worker := range workers {
			workerNameSlice = append(workerNameSlice, worker.UID)
		}
		workerNames = &workerNameSlice
	} else {
		workerList = &meta.WorkerList{}
		for _, worker := range workers {
			workerList.Items = append(workerList.Items, *worker)
		}
	}

	args = &ExtenderArgs{
		Stage:       stage,
		Workers:     workerList,
		WorkerNames: workerNames,
	}

	if err := h.send(h.filterVerb, args, &result); err != nil {
		return nil, nil, nil, err
	}
	if result.Error != "" {
		return nil, nil, nil, errors.New(result.Error)
	}

	if h.workerCacheCapable && result.WorkerNames != nil {
		workerResult = make([]*meta.Worker, len(*result.WorkerNames))
		for i, workerName := range *result.WorkerNames {
			if n, ok := fromWorkerName[workerName]; ok {
				workerResult[i] = n
			} else {
				return nil, nil, nil, fmt.Errorf(
					"extender %q claims a filtered worker %q which is not found in the input worker list",
					h.extenderURL, workerName)
			}
		}
	} else if result.Workers != nil {
		workerResult = make([]*meta.Worker, len(result.Workers.Items))
		for i := range result.Workers.Items {
			workerResult[i] = &result.Workers.Items[i]
		}
	}

	return workerResult, result.FailedWorkers, result.FailedAndUnresolvableWorkers, nil
}

func (h *HTTPExtender) Prioritize(stage *meta.Stage, workers []*meta.Worker) (hostPriorities *framework.HostPriorityList, weight int64, err error) {
	var (
		result      framework.HostPriorityList
		workerList  *meta.WorkerList
		workerNames *[]string
		args        *ExtenderArgs
	)

	if h.prioritizeVerb == "" {
		result := framework.HostPriorityList{}
		for _, worker := range workers {
			result = append(result, framework.HostPriority{Host: worker.Host, Score: 0})
		}
		return &result, 0, nil
	}

	if h.workerCacheCapable {
		workerNameSlice := make([]string, 0, len(workers))
		for _, worker := range workers {
			workerNameSlice = append(workerNameSlice, worker.UID)
		}
		workerNames = &workerNameSlice
	} else {
		workerList = &meta.WorkerList{}
		for _, worker := range workers {
			workerList.Items = append(workerList.Items, *worker)
		}
	}

	args = &ExtenderArgs{
		Stage:       stage,
		Workers:     workerList,
		WorkerNames: workerNames,
	}

	if err := h.send(h.prioritizeVerb, args, &result); err != nil {
		return nil, 0, err
	}
	return &result, h.weight, nil
}

func (h *HTTPExtender) Bind(binding *meta.Binding) error {
	var result ExtenderBindingResult
	if !h.IsBinder() {
		return fmt.Errorf("unexpected empty bindVerb in extender")
	}
	req := map[string]interface{}{
		"StageName": binding.Name,
		"StageUID":  binding.UID,
		"Worker":    binding.Target,
	} // fixme
	if err := h.send(h.bindVerb, req, &result); err != nil {
		return err
	}
	if result.Error != "" {
		return errors.New(result.Error)
	}
	return nil
}

func (h *HTTPExtender) IsBinder() bool {
	return h.bindVerb != ""
}

func (h *HTTPExtender) IsInterested(stage *meta.Stage) bool {
	if len(h.managedResources) == 0 {
		return true
	}
	if h.hasManagedResources(stage.WorkerHost) {
		return true
	}
	return false
}

func (h *HTTPExtender) ProcessPreemption(stage *meta.Stage, workerNameToVictims map[string]interface{}, workerInfos interface{}) (map[string]interface{}, error) {
	return nil, nil
}

func (h *HTTPExtender) SupportsPreemption() bool {
	return len(h.preemptVerb) > 0
}

func (h *HTTPExtender) IsIgnorable() bool {
	return h.ignorable
}

func (h *HTTPExtender) hasManagedResources(resources interface{}) bool {
	return false // todo
}

// Helper function to send messages to the extender
func (h *HTTPExtender) send(action string, args interface{}, result interface{}) error {
	out, err := json.Marshal(args)
	if err != nil {
		return err
	}

	url := strings.TrimRight(h.extenderURL, "/") + "/" + action

	req, err := http.NewRequest("POST", url, bytes.NewReader(out))
	if err != nil {
		return err
	}

	req.Header.Set("Content-Type", "application/json")

	resp, err := h.client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("failed %v with extender at URL %v, code %v", action, url, resp.StatusCode)
	}

	return json.NewDecoder(resp.Body).Decode(result)
}
